<#@ Include File="ST4bby.Config.ttinclude" #>
<#@ Assembly Name="System.Xml" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="Microsoft.SqlServer.ConnectionInfo" #>
<#@ Assembly Name="Microsoft.SqlServer.SqlEnum" #>
<#@ Assembly Name="Microsoft.SqlServer.Management.Sdk.Sfc" #>
<#@ Assembly Name="Microsoft.SqlServer.Smo" #>
<#@ Assembly Name="System.Data" #>
<#@ Assembly Name="EnvDTE" #>
<#@ Import Namespace="Microsoft.SqlServer.Management.Smo" #>
<#@ Import Namespace="System.Xml.Serialization" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Data.Common" #>
<#@ Import Namespace="System.Text.RegularExpressions" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="Microsoft.SqlServer.Management.Common" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ import namespace="EnvDTE" #>
<#
  if (ConfigIsValid())
    {
      var connectionString = GetConnectionString();
        using(SqlConnection conn = new SqlConnection(connectionString))
        {
            var serverConnection = new ServerConnection(conn);
            var tables = new Server(serverConnection).Databases[databaseName].Tables;

            OutputXml( new Server(serverConnection).Databases[databaseName] );
            var xmlPath = SaveOutput( "ST4bby.xml" );
            AddFileToProject( xmlPath );

            var textReader = new XmlTextReader( xmlPath );
            var xmldoc = new XmlDocument();
            xmldoc.Load( textReader );
            textReader.Close();
            // TODO: Change namespace parameter to constant.
            OutputSurface( "DataLayer.Surface", xmldoc );
            
            foreach (Table table in tables)
            {
                if ( IsClassOkToGenerate( table ) )
                {
                    OutputClass(nameSpaceName, table);
                    var path = SaveOutput(table.Name + ".cs");
                    // total hack but it adds the newly written file into the current visual studio instance
                    var project = GetCurrentProject();

                    project.ProjectItems.AddFromFile(path);
                }
            }
            
        }
    }
#>
<#+
	
    //  http://msdn.microsoft.com/en-us/library/bb386947.aspx
    private readonly static Dictionary<string, string> TypeMappings = new Dictionary<string, string> 
    {
        { "bit","bool" },           { "uniqueidentifier","Guid" },
        { "datetime","DateTime" },  { "datetime2","DateTime" },
        { "int","int" },            { "smallint","short" },
        { "bigint","long" },        { "varchar","string" },
        { "nchar","char" },         { "char","char" },
        { "nvarchar","string" },    { "text","string" },
        { "ntext","string" }
    };
	
    private void AddFileToProject( string xmlPathAndFile )
    {
        // total hack but it adds the newly written file into the current visual studio instance
        var project = GetCurrentProject();
        project.ProjectItems.AddFromFile( xmlPathAndFile );
    }

    public EnvDTE.Project GetCurrentProject()
    {
        var serviceProvider             = (IServiceProvider)Host;
        var dte                         = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
        var currentSlnProjects          = (Array)dte.ActiveSolutionProjects;

        return (EnvDTE.Project)currentSlnProjects.GetValue(0);
    }
	
	/// <summary> This method creates the signature for the class.
    /// E.g.: public partial class Customer()
    /// </summary>
    /// <param name="table"></param>
    /// <param name="usePartialClass"></param>
    /// <returns></returns>
   private static string CreateClassSignature( Table table, bool usePartialClass )
   {
        var ret = "public";
        if( usePartialClass )
        {
            ret += " partial";
        }
        ret += " class " + table.Name;
        if( false == string.IsNullOrWhiteSpace( ClassInheritFrom ) )
        {
            ret += " : " + ClassInheritFrom;
        }
        return ret;
   }

    private static string CreateSurfaceClassSignature( string tableName )
    {
        // TODO: Should we rewrite CreateClassSignature to look like this one
        // or should we use more parameters (one per setting) and create a
        // more generic CreateClassSignature method?
        var ret = string.Format( 
            "public {0} class {1}{2}", 
            UsePartialClass ? " partial" : "", 
            string.Format( 
                SurfaceTableNameFormat.IndexOf( "{0}" ) == -1 ? 
                    "{0}" + SurfaceTableNameFormat : 
                    SurfaceTableNameFormat, 
                tableName 
            ), 
            string.IsNullOrWhiteSpace( SurfaceClassInheritFrom ) ? "" : " : " + SurfaceClassInheritFrom
        );
        return ret;
   }

    private static string CreateFileHeader( string commentPrefix, string commentSuffix = null )
    {
        return 
            string.Format( 
            "{2} This class is automatically generated by ST4bby {1}.{3]{0}" +
            "{2} Read more at https://github.com/jbubriski/ST4bby/{3}" , 
                Environment.NewLine, 
                System.DateTime.Now.ToString(), 
                commentPrefix, 
                commentSuffix );
    }

    private string CreateMethodSig( IEnumerable<XmlElement> usedColumns )
    {
        return string.Join( ",", usedColumns.Select( c => c.Attributes["Name"].Value ) );
     }

	/// <summary> This method creates the namespace signature.
	/// </summary>
	/// <param name="namespaceName"></param>
	/// <param name="table"></param>
	/// <param name="useSchemaForNamespace"></param>
	/// <returns></returns>
	private static string CreateNamespaceSignature( string namespaceName, Table table, bool useSchemaForNamespace )
	{
		string ret = string.Format( "namespace {0}", namespaceName );
		if( useSchemaForNamespace )
		{
			ret += "." + table.Schema;
		}
		return ret;
	}

	private static string CreateSurfaceNamespaceSignature( string namespaceName, bool useSchemaForNamespace )
	{
		string ret = string.Format( "namespace {0}", namespaceName );
		return ret;
	}

	
    /// <summary> This method creates a parameter for a method from a column.
    /// E.g.: "int CustomerID" or "string Name".
    /// </summary>
    /// <param name="column"></param>
    /// <returns></returns>
	private static string CreateMethodParameter( Column column )
	{
        var isNullable       = column.Nullable;
        var type             = TypeMappings.ContainsKey(column.DataType.Name) ? TypeMappings[column.DataType.Name] : "string";
        var typeFormat       = type != "string" && isNullable ? "Nullable<{0}>" : "{0}";

        return String.Format("{0} {1}", String.Format(typeFormat,type), column.Name);
	}

    private static string CreateMethodParameter( XmlNode node )
    {
        var isNullable = bool.Parse( node.Attributes["IsNullable"].Value );
        var parameterName = node.Attributes["Name"].Value;
		var parameterType = node.Attributes["DotnetType"].Value;
        var type = TypeMappings.ContainsKey( parameterType ) ? 
			TypeMappings[parameterType] : "string";
        var typeFormat       = type != "string" && isNullable ? "Nullable<{0}>" : "{0}";
        return String.Format("{0} {1}", String.Format(typeFormat,type), parameterName);
    }

    private static IEnumerable<string> CreateMethodParameterList( 
        IEnumerable<XmlNode> nodeList, 
        bool includePrimaryKey = true )
    {
        if( includePrimaryKey )
        {
            return nodeList.Select( c => CreateMethodParameter( c ) );
        }
        else
        {
            return nodeList
                .Where( c => bool.Parse( c.Attributes["IsPrimaryKey"].Value ) == false )
                .Select( c => CreateMethodParameter( c ) );
        }
    }

    private static string CreateMethodParameterListString( 
        IEnumerable<XmlNode> nodeList, 
        bool includePrimaryKey = true )
    {
        return string.Join( ", ", CreateMethodParameterList( nodeList, includePrimaryKey ) );
    }

    private static string CreateQuerySelectEqualParameter( XmlNode node )
    {
        return string.Format( "{0} = @{1}", 
            node.Attributes["Name"].Value, 
            node.Attributes["Name"].Value
        );
    }
	
	private static string CreateQueryInsertParameterListString( IEnumerable<XmlElement> columnList )
	{
		return string.Join( ", ", columnList.Select( c => c.Attributes["Name"].Value ) );
	}

	private static string CreateQueryInsertParameterListStringWithAtSign( IEnumerable<XmlElement> columnList )
	{
		return string.Join( ", ", columnList.Select( c => "@" + c.Attributes["Name"].Value ) );
	}

    private static IEnumerable<string> CreateQuerySelectEqualParameterList( IEnumerable<XmlNode> nodeList )
    {
        return nodeList.Select( c => CreateQuerySelectEqualParameter( c ) );
    }

    private static string CreateQuerySelectEqualParameterListString( IEnumerable<XmlNode> nodeList )
    {
        return string.Join( " and ", CreateQuerySelectEqualParameterList( nodeList ) );
    }

    private static string CreateObjectAssignmentParameter( XmlNode node )
    {
        return string.Format( "{0} = {1}", 
            node.Attributes["Name"].Value, 
            node.Attributes["Name"].Value
        );        
    }

    private static IEnumerable<string> CreateObjectAssignmentParameterList( IEnumerable<XmlNode> nodeList )
    {
        return nodeList.Select( n => CreateObjectAssignmentParameter( n ) );
    }

    private static string CreateObjectAssignmentParameterListString( IEnumerable<XmlNode> nodeList )
    {
        return string.Join( ", ", CreateObjectAssignmentParameterList( nodeList ) );
    }

    /// <summary> This method creates a method signature.
    /// E.g.: "private void Set( CustomerID, Name )".
    /// </summary>
    /// <param name="scope"></param>
    /// <param name="isStatic"></param>
    /// <param name="returnType"></param>
    /// <param name="methodName"></param>
    /// <param name="columns"></param>
    /// <param name="includePrimaryKey">Whether the primary key should be included or not.
    /// New objects often can't have the PK set at the client, only in the database.</param>
    /// <returns></returns>
	private static string CreateMethodSignature( string scope, bool isStatic, string returnType, string methodName, ColumnCollection columns, bool includePrimaryKey = true )
	{
		string ret = scope;
		if( isStatic )
		{
			ret += " static";
		}
		if( false == string.IsNullOrWhiteSpace( returnType ) )
		{
			ret += " " + returnType;
		}
		ret += " " + methodName + "(";
		if( null != columns )
		{
			var paramList = new List<string>();
			foreach( Column column in columns )
			{
				if( column.InPrimaryKey && ! includePrimaryKey )
				{
					//	The column is part of the primary key and we don't want it according to parameter.
				}
				else
				{
					paramList.Add( CreateMethodParameter( column ) );
				}
			}
			ret += " " + string.Join( ", ", paramList.ToArray() ) + " ";
		}
		ret += ")";
		return ret;
	}

    /// <summary> This method creates all parameters for a constructor.
    /// It is not necessarily only for constructor use.  A method like "Set( CustomerID, Name, ...)"
    /// could use it too.  Rename it when need arises.
    /// </summary>
    /// <param name="columns"></param>
    /// <param name="includePrimaryKey"></param>
    /// <returns></returns>
	private static string CreateNamedArgumentListForConstructor( ColumnCollection columns, bool includePrimaryKey = true )
	{
		var assignmentList = new List<string>();
		foreach( Column column in columns )
		{
			if( column.InPrimaryKey && ! includePrimaryKey )
			{
				//	The column is part of the primary key and we don't want it according to parameter.
			}
			else
			{
				assignmentList.Add( column.Name + " = " + column.Name );
			}	
		}
		return string.Join( "," + Environment.NewLine, assignmentList.ToArray() );
	}
	
    /// <summary> This method returns true if the table is among the ones that should generate code.
    /// Typically aren't system objects and explicitly excluded tables among those.
    /// </summary>
    /// <param name="table">The table in question.</param>
    /// <returns></returns>
    private bool IsClassOkToGenerate( Table table )
    {
        if( false == string.IsNullOrWhiteSpace( ExcludeTablesRegex ) &&
            ( table.IsSystemObject || Regex.IsMatch( table.Name, ExcludeTablesRegex ) ) )
        {
            return false;
        }else{
            return true;
        }
    }

	private string OutputProperty(Column column)
    {
        var isNullable       = column.Nullable;
        var type             = TypeMappings.ContainsKey(column.DataType.Name) ? TypeMappings[column.DataType.Name] : "string";
        var typeFormat       = type != "string" && isNullable ? "Nullable<{0}>" : "{0}";

        var annotations      = GetAnnotations(column);

        return String.Format("{0}public {1} {2} {{ get; set; }}", annotations, String.Format(typeFormat,type), column.Name);
    }

    string GetAnnotations(Column col)
    {
      var builder = new List<string>();
        var canHaveLength = new string[] { "nvarchar", "varchar", "char", "nchar" };
        if (canHaveLength.Contains(col.DataType.Name) && col.DataType.MaximumLength > -1)
            builder.Add( String.Format("StringLength({0})", col.DataType.MaximumLength));

        if (!col.Nullable)
            builder.Add("Required");

        if (col.InPrimaryKey)
          builder.Add("Key");

        var notations = String.Join(", ", builder);
      return builder.Count > 0 ? String.Format("[{0}]{1}", notations, System.Environment.NewLine) : String.Empty;
  }

    System.Collections.Generic.IEnumerable<string> GatherProperties(ColumnCollection columns)
    {
        foreach (Column col in columns)
            yield return OutputProperty(col);
    }

    void Out(string stuff)
    {
#><#= stuff + System.Environment.NewLine #><#+
    }

    void Out(string stuff, params object[] args)
    {
#><#= String.Format(stuff, args) + System.Environment.NewLine #><#+
    }

    private void Out_Text( string stuff )
    {
        // http://msdn.microsoft.com/en-us/library/system.stringsplitoptions.aspx
        // http://www.dotnetperls.com/split
        List<string> stuffList = stuff.Split(new string[] { Environment.NewLine }, StringSplitOptions.None).ToList();

        // Remove the first line if it is totally empty.
        // @"
        // mystring"
        // has two strings and the first is empty.  remove it.
        if( stuffList[0].Length == 0 )
        {
            stuffList.RemoveAt(0);
        }

        // First find the amount of indentation the first line of the source text has.  We must
        // remove this indentation from every row before outputting.
		//	We must also decide if there are leading tabs or spaces.  We prefer spacex4 in 
		//	this file but sometimes a tab creeps in.
        var charIndentCount = stuffList.First().ToCharArray().TakeWhile( c => c == ' ' ).Count();
        var tabIndentCount = stuffList.First().ToCharArray().TakeWhile( c => c == '\t' ).Count();
		var indentCount = Math.Max( charIndentCount, tabIndentCount );
		
        foreach( string t in stuffList )
        {
            if( t.Length >= indentCount )
            {
                Out( t.Remove( 0, indentCount ) );
            }
            else
            {
                Out( t );
            }
        }
    }

    void Out_Text(string stuff, params object[] args)
    {
        Out_Text( String.Format(stuff, args) );
    }

    private void Out_SurfaceDeleteMethod( string tableName, IEnumerable<XmlNode> columnsUsedInIxFk )
    {
        // TODO: Move method signature creator to a method of its own.
        // TODO: Set schema by parameter, not hard coded as right now.  Schema=
        // TODO: Set namespace by setting, not hard coded DTO as now.
        // TODO: Write a comment to the method that deletes by the primary key that it does just that.
        Out( "public void DeleteBy{0}( {1} )", 
            string.Join( "And", columnsUsedInIxFk.Select( c => c.Attributes["Name"].Value ) ), 
            CreateMethodParameterListString( columnsUsedInIxFk )
            );
		Out("{");
        PushIndent("\t");
            Out_Text( @"
                var ctx = MakeConnectionAndTransaction();
                ctx.Conn.Open();
                ctx.Conn.Execute( 
                    {0}, 
                    {1} );", 
                string.Format( 
                    "\"delete from {0} where {1}\"", 
                    tableName, 
                    CreateQuerySelectEqualParameterListString( columnsUsedInIxFk )
                ), 
                string.Format( 
                    "new {{ {0} }}", 
                    CreateObjectAssignmentParameterListString( columnsUsedInIxFk ) )
            );
        PopIndent();
		Out("}");
    }

    string SaveOutput(string outputFileName)
    {
        // By some reason unknown to me the file the string contains a leading whitespace.  Hence the Trim.
        // This happened to me while writing an XML file which doesn't tolerate a leading whitespace. /OF
      var content = this.GenerationEnvironment.ToString().Trim();

      string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
      string outputFilePath = Path.Combine(templateDirectory, outputFileName);

        File.WriteAllText(outputFilePath, content);

      this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);

        return outputFilePath;
    }

    void OutputClass(string namespaceName, Table table)
    {
		Out("// This class is automatically generated by ST4bby {0}.", System.DateTime.Now.ToString());
		Out("// Read more at https://github.com/jbubriski/ST4bby/");
		Out("");
		Out( CreateNamespaceSignature( namespaceName, table, UseSchemaForNamespace ) );
		Out("{");
		PushIndent("\t");
			Out("using System;");
			Out("using System.ComponentModel.DataAnnotations;");
			Out( "" );
			Out( CreateClassSignature( table, UsePartialClass ) );
			Out("{");
			PushIndent("\t");
				//	Properties.
				var properties = GatherProperties(table.Columns);
				Out(String.Join(System.Environment.NewLine, properties));
		
				//	Static constructors.
				if( false == string.IsNullOrWhiteSpace( NameOfStaticConstructor ) )
				{
					Out("");
			        Out( "/// <summary> This static constructor takes all fields but the primary key." );
			        Out( "/// </summary>");
			        Out( "/// <returns></returns>");
					Out( CreateMethodSignature( "public", true, table.Name, NameOfStaticConstructor, table.Columns, includePrimaryKey : false ) );
					Out("{");
					PushIndent("\t");
						Out( "return new " + table.Name + "()" );
						Out( "{" );
						PushIndent("\t");
							Out( CreateNamedArgumentListForConstructor( table.Columns, includePrimaryKey : false ) );
						PopIndent();
						Out( "};" );
					PopIndent();
					Out("}");
					Out("");
			        Out( "/// <summary> This static constructor takes all fields including the primary key." );
			        Out( "/// </summary>");
			        Out( "/// <returns></returns>");
					Out( CreateMethodSignature( "public", true, table.Name, NameOfStaticConstructor, table.Columns ) );
					Out("{");
					PushIndent("\t");
						Out( "return new " + table.Name + "()" );
						Out( "{" );
						PushIndent("\t");
							Out( CreateNamedArgumentListForConstructor( table.Columns, includePrimaryKey : true ) );
						PopIndent();
						Out( "};" );
					PopIndent();
					Out("}");
				}
			PopIndent();
			Out("}");
		PopIndent();
		Out("}");
    }

    private void OutputSurface( string namespaceName, XmlDocument document )
    {
        // We don't handle schema so to tables with the same name, in different schemas, 
        // will mess up the code generation.
        var root = document.DocumentElement;
        var nodeList = root.SelectNodes( "/Database/Tables/Table[@Include=\"True\"]" );
        foreach( XmlElement node in nodeList )
        {
            var fileName = OutputSurfaceFile( namespaceName, node );
            var surfacePathFile = SaveOutput( fileName );
            AddFileToProject( surfacePathFile );
        }
    }

    private string OutputSurfaceFile( string namespaceName, XmlElement tableElement)
    {
        var tableName = tableElement.Attributes["Name"].Value;

        ClearIndent();
		Out("// This class is automatically generated by ST4bby {0}.", System.DateTime.Now.ToString());
		Out("// Read more at https://github.com/jbubriski/ST4bby/");
		Out("");
		Out( "using System;");
        Out( "using System.Collections.Generic;" );
		Out( "using System.ComponentModel.DataAnnotations;");
        Out( "using System.Linq;");
        Out( "using Dapper;");
		Out( "" );
		Out( CreateSurfaceNamespaceSignature( namespaceName, UseSchemaForNamespace ) );
		Out("{");
		PushIndent("\t");
			Out( CreateSurfaceClassSignature( tableName ) );
			Out("{");
			PushIndent("\t");

            //  Find all colums for the Table.
            var columnList = ToList( tableElement.SelectNodes( "Columns/Column" ) ).Cast<XmlElement>();

            Out_SurfaceInsertMethods( tableName, tableElement, columnList );

            Out_SurfaceFindMethods( tableName, tableElement, columnList );
        
            Out_SurfaceUpdateMethods( tableName, tableElement, columnList );

            Out_SurfaceDeleteMethods( tableName, tableElement, columnList );
                
			PopIndent();
			Out("}");
		PopIndent();
		Out("}");
        return string.Format( "{0}Surface.ST4bby.cs", tableName );
    }
    
    private void Out_SurfaceFindMethods( 
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList )
    {
        //  We have a problem where an index and a fk points at the same columns.
        //  In those cases we get two identical methods; which we can't have.
        //  Each method declares a unique signature due to its parameters.
        //  The solution is such:
        //  We store the unique parameters for each method created.  The
        //  parameters are created from the columns used so if we store the 
        //  columns we also have a unique identificator of each method.
        //  Then we make sure the same signature is not used twice.
        var methodSigList = new HashSet<string>();

        //  Start by creating a FindAll method.
        Out_Comment( "This method returns all records in the table " + tableName + "." );
        Out_Text( @"
            public List<{0}.{1}> FindAll()
            {{
                using( var conn = CreateConnection() )
                {{
                    conn.Open();
                    var res = conn.Query<{0}.{1}>( {2} );
                    return res.ToList();
                }}
            }}", 
            nameSpaceName, 
            tableName, 
            "\"select * from " + tableName + "\""
        );
        Out( "" );

        //  Find all the indexes for the table.
        var ixNodeList = ToList( tableElement.SelectNodes( "Indexes/Index" ) ).Cast<XmlElement>();
        Out_SurfaceFindMethods( tableName, tableElement, columnList, ixNodeList, methodSigList );

        // Find every FK for the Table.  We want 1 method per FK since every FK can be searched on.
        var fkNodeList = ToList( tableElement.SelectNodes( "ForeignKeys/ForeignKey" ) ).Cast<XmlElement>();
        Out_SurfaceFindMethods( tableName, tableElement, columnList, fkNodeList, methodSigList );
    }

    private void Out_SurfaceFindMethods( 
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList, 
        IEnumerable<XmlElement> ixfkNodeList, 
        HashSet<string> methodSigList )
    {
        //  Loop the indexes/fks and create one Find-method per index or fk.
        foreach( XmlElement indexElement in ixfkNodeList )
        {
            //  Filter out the columns that are used for this index.
            //  Note that the table's columns come from tableElement->Columns/Column
            //  while the index's columns come from indexElement->Columns/Column.
            var usedColumns = ColumnsFromIndexOrForeignKey( indexElement, columnList );

            var paramString = CreateMethodSig( usedColumns );
            if( methodSigList.Contains( paramString ) )
            {
                Out( "// There is already a method with parameter(s) {0}.  Do you have redundant indexes or foreign keys?", paramString );
                Out( "" );
            }
            else
            {
                methodSigList.Add( paramString );    // Add the new unique string of method parameters.

                // TODO: Comment that this is the method to search via the PK, if it is the pk.
                // TODO: The method should return a single value if the index, like pk, is unique.
                Out_Comment( 
                    string.Format( @"This method uses the {1} index{0}for searching of field(s) {2}.", 
                        Environment.NewLine, 
                        indexElement.Attributes["Name"].Value, 
                        string.Join( " and ", usedColumns.Select( n=>n.Attributes["Name"].Value ) )
                    ), 
                    usedColumns.Select( c => c.Attributes["Name"].Value ), 
                    ""
                );
                Out_SurfaceFindMethod( tableName, usedColumns );
                Out( "" );
            }
        }
    }

    private void Out_SurfaceFindMethod( string tableName, IEnumerable<XmlNode> columnsUsedInIxFk )
    {
        // TODO: Move method signature creator to a method of its own.
        // TODO: Set schema by parameter, not hard coded as right now.  Schema=
        // TODO: Set namespace by setting, not hard coded DTO as now.
        // TODO: Write a comment to the method that selects the primary key that it does just that.  It should also return just 1 record.
        Out( "public List<DTO.{0}> FindBy{1}( {2} )", 
            tableName, 
            string.Join( "And", columnsUsedInIxFk.Select( c => c.Attributes["Name"].Value ) ), 
            CreateMethodParameterListString( columnsUsedInIxFk )
            );
		Out_Text( @"
			{{
				var ctx = MakeConnectionAndTransaction();
				var res = ctx.Conn.Query<DTO.{0}>( 
					{1},
					{2},
					transaction: ctx.Trans );
				return res.ToList();
			}}", 
				tableName, 
				"\"select * from " + tableName + " where " + CreateQuerySelectEqualParameterListString( columnsUsedInIxFk ) + "\"", 
                "new { " + CreateObjectAssignmentParameterListString( columnsUsedInIxFk ) + " }"
			);
    }

    private void Out_SurfaceInsertMethods( 
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList )
    {
		Out_SurfaceInsertMethod(
			tableName, 
			tableElement, 
			columnList.Where( c => bool.Parse( c.Attributes["IsPrimaryKey"].Value ) == false )
		);
    }
	
    private void Out_SurfaceInsertMethod( 
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList )
    {
		// TODO: Move method signature creator to a method of its own.
        // TODO: Set schema by parameter, not hard coded as right now.  Schema=
        // TODO: Set namespace by setting, not hard coded DTO as now.
        Out_Comment(
            "This method inserts every field in the " + tableName + " table" +
            " exclusive the primary key(s).", 
            columnList.Select( c => c.Attributes["Name"].Value )
        );
        Out_Text( "public int Insert( {0} )", 
        	CreateMethodParameterListString( columnList )
        );
		
		Out_Text( @"
			{{
				var ctx = MakeConnectionAndTransaction();
				ctx.Conn.Execute( 
					{0}, 
					{1},
					ctx.Trans
				);
				var res = ctx.Conn.Query<float>(
					{2},
					ctx.Trans
				);
				return (int)res.Single();
			}}"
		, 
			"\"insert into " + tableName +
				" ( " + CreateQueryInsertParameterListString( columnList ) + " )" +
				" values( " + CreateQueryInsertParameterListStringWithAtSign( columnList ) + " )\"",
			"new { " + CreateObjectAssignmentParameterListString( columnList ) + "}", 
			"\"select @@identity\""
		);
		Out( "" );
	}
	
    private void Out_SurfaceUpdateMethods(
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList )
    {
        Out_SurfaceUpdateMethod( tableName, tableElement, 
            columnList.Where( c => bool.Parse( c.Attributes["IsPrimaryKey"].Value ) == false ), 
            false
        );
        Out_SurfaceUpdateMethod( tableName, tableElement, columnList, true );
    }

    private void Out_SurfaceUpdateMethod(
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList, 
        bool includePrimaryKey )
    {
        // TODO: Move method signature creator to a method of its own.
        // TODO: Set schema by parameter, not hard coded as right now.  Schema=
        // TODO: Set namespace by setting, not hard coded DTO as now.
		// TODO: Make it possible to set setting for reading the record after writing it.
        Out_Comment(
            "This method updates every field in the " + tableName + " table" +
            ( includePrimaryKey ? "." : " exclusive the primary key(s)." ), 
            columnList.Select( c => c.Attributes["Name"].Value )
        );
        Out( "public void Update( {0} )", 
            CreateMethodParameterListString( columnList )
        );
        Out( "{" );
        PushIndent( "\t" );
            Out_Text( @"
				var ctx = MakeConnectionAndTransaction();
				ctx.Conn.Execute(
					{0},
					{1}, 
					ctx.Trans);", 
                string.Format( 
                    "\"update {1} set {2}\"", 
                    Environment.NewLine, 
                    tableName, 
                    CreateQuerySelectEqualParameterListString( columnList )
                    ), 
                string.Format( 
                    "new {{ {0} }}", 
                    CreateObjectAssignmentParameterListString( columnList ) )
             );
        PopIndent();
        Out( "}" );
        Out( "" );
    }

    private void Out_SurfaceDeleteMethods( 
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList )
    {
        //  We have a problem where an index and a fk points at the same columns.
        //  In those cases we get two identical methods; which we can't have.
        //  Each method declares a unique signature due to its parameters.
        //  The solution is such:
        //  We store the unique parameters for each method created.  The
        //  parameters are created from the columns used so if we store the 
        //  columns we also have a unique identificator of each method.
        //  Then we make sure the same signature is not used twice.
        var methodSigList = new HashSet<string>();

        Out_Comment( "This method deletes all records in the " + tableName + " table." );
        Out_Text( @"
            public void DeleteAll()
            {{
                using( var conn = CreateConnection() )
                {{
                    conn.Open();
                    conn.Execute( {0} );
                }}
            }}", 
            "\"delete from " + tableName + "\""  );
        Out( "" );
            
        //  Find all the indexes for the table.
        var ixNodeList = ToList( tableElement.SelectNodes( "Indexes/Index" ) ).Cast<XmlElement>();
        Out_SurfaceDeleteMethods( tableName, tableElement, columnList, ixNodeList, methodSigList );

        // Find every FK for the Table.  We want 1 method per FK since every FK can be searched on.
        var fkNodeList = ToList( tableElement.SelectNodes( "ForeignKeys/ForeignKey" ) ).Cast<XmlElement>();
        Out_SurfaceDeleteMethods( tableName, tableElement, columnList, fkNodeList, methodSigList );
        
    }

    private static IEnumerable<XmlElement> ColumnsFromIndexOrForeignKey(
        XmlElement indexOrFkElement, 
        IEnumerable<XmlElement> columnList )
    {
        //  Filter out the columns that are used for this index.
        //  Note that the table's columns come from tableElement->Columns/Column
        //  while the index's columns come from indexElement->Columns/Column.
        var usedColumns = 
            from c in columnList
            where ToList( indexOrFkElement.SelectNodes( "Columns/Column" ) )
                .Select( ic => ic.Attributes["Name"].Value ).ToList()
                .Contains( c.Attributes["Name"].Value )
            select c;
        return usedColumns;
    }

    private void Out_SurfaceDeleteMethods( 
        string tableName, 
        XmlElement tableElement, 
        IEnumerable<XmlElement> columnList, 
        IEnumerable<XmlElement> ixfkNodeList, 
        HashSet<string> methodSigList )
    {
        //  Loop the indexes/fks and create one Find-method per index or fk.
        foreach( XmlElement indexElement in ixfkNodeList )
        {
            //  Filter out the columns that are used for this index.
            //  Note that the table's columns come from tableElement->Columns/Column
            //  while the index's columns come from indexElement->Columns/Column.
            var usedColumns = ColumnsFromIndexOrForeignKey( indexElement, columnList );

            var paramString = CreateMethodSig( usedColumns );
            if( methodSigList.Contains( paramString ) )
            {
                Out( "// There is already a method with parameter(s) {0}.  Do you have redundant indexes or foreign keys?", paramString );
                Out( "" );
            }
            else
            {
                methodSigList.Add( paramString );    // Add the new unique string of method parameters.


                // TODO: Comment that this is the method to delete via the PK, if the isfk is the pk/unique.
                Out_Comment( 
                    string.Format( @"This method uses the {1} index/fk{0}for deleting a record.  Filtering is dune by field(s) {2}.", 
                        Environment.NewLine, 
                        indexElement.Attributes["Name"].Value, 
                        string.Join( " and ", usedColumns.Select( n=>n.Attributes["Name"].Value ) )
                    ), 
                    usedColumns.Select( c => c.Attributes["Name"].Value ), 
                    ""
                );
                Out_SurfaceDeleteMethod( tableName, usedColumns );
                Out( "" );
            }
        }
    }

    private void Out_Comment( string summaryText, IEnumerable<string> parameterList = null, string returnText = null )
    {

        //  Print the Summary part.
        var summaryTextArray = Regex.Split( summaryText, Environment.NewLine );
        for( var i=0 ; i<summaryTextArray.Count() ; ++i )
        {
            if( i == 0 )
            {
                Out( "/// <summary>" + summaryTextArray[0] );
            }
            else
            {
                Out( " /// " + summaryTextArray[i] );
            }
        }
        Out( "/// </summary>" );

        //  Print the Parameters part.
        if( parameterList != null )
        {
            foreach( string parameter in parameterList )
            {
                Out( "/// <param name=\"" + parameter + "\"></param>" );
            }
        }

        //  Print the Returns part.
        if( returnText != null )
        {
            // TODO: Create a proper return text split as with Summary.
            Out( "/// <returns>" + returnText + "</returns>" );
        }
    }

    private static List<XmlNode> ToList( XmlNodeList nodeList )
    {
        // I would have preferred to use AsQueryable as MSDN says.  But I can't get it to work. /OF
        //  http://msdn.microsoft.com/en-us/library/system.xml.xmlnodelist.aspx
        // E.g.: var x = fkElement.SelectNodes( "Columns/Column" ).AsQueryable();

        var ret = new List<XmlNode>();
        foreach( XmlNode node in nodeList )
        {
            ret.Add( node );
        }
        return ret;
    }

    private void OutputXml( Database database )
    {
        //  http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.aspx

        var doc = new XmlDocument();

        // Important to set the ProcessingInstruction through code, otherwise we will have no
        // DocumentElement to use. (so we do a doc.appendChild and then we suddenly
        // have 2 roots)
        doc.AppendChild(doc.CreateProcessingInstruction("xml", "version=\"1.0\" encoding=\"UTF-8\""));

        var elem = doc.CreateElement( "Database" );
        doc.AppendChild( elem );
        var databaseRoot = doc.DocumentElement;

        InsertCommentBefore( databaseRoot, "This class is automatically generated by ST4bby " + DateTime.Now.ToString() + "." );
        InsertCommentBefore( databaseRoot, "Read more at https://github.com/jbubriski/ST4bby/" );

        AppendAttribute( databaseRoot, "Name", database.Name );
        
        var tablesElement = AppendChildElement( databaseRoot, "Tables" );

        foreach( Table table in database.Tables )
        {
            var tableElement = AppendChildElement( tablesElement, "Table" );
            AppendAttribute( tableElement, "Name", table.Name );
            AppendAttribute( tableElement, "Include", IsClassOkToGenerate( table ) );
            AppendAttribute( tableElement, "Schema", table.Schema );
            InsertCommentBefore( tableElement, "Name is the tablename, " + 
                "Include is if the table should be included (all tables are in the schema but not all should become code, " +
                "and Schema is the schema the table is in." );

            var columnsElement = AppendChildElement( tableElement, "Columns" );

            foreach( Column column in table.Columns )
            {
                var columnElement = AppendChildElement( columnsElement, "Column" );
                AppendAttribute( columnElement, "Name", column.Name );
                AppendAttribute( columnElement, "IsNullable", column.Nullable );
                AppendAttribute( columnElement, "DbType", column.DataType.ToString() );
                var type = TypeMappings.ContainsKey(column.DataType.Name) ? TypeMappings[column.DataType.Name] : "string";
                var typeFormat       = type != "string" && column.Nullable ? "Nullable<{0}>" : "{0}";
                AppendAttribute( columnElement, "DotnetType", String.Format(typeFormat,type) );
                AppendAttribute( columnElement, "IsPrimaryKey", column.InPrimaryKey );
                AppendAttribute( columnElement, "IsForeignKey", column.IsForeignKey );
                AppendAttribute( columnElement, "IsIdentity", column.Identity );  // Is really "identity" a good word for "autocounting pk" or whatever is a better name?
                AppendAttribute( columnElement, "Length", column.DataType.MaximumLength );

                //  Foreign keys are printed if any exists.
                //  http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.foreignkey.aspx
                if( column.EnumForeignKeys().Rows.Count >= 1 )
                {
                    var columnForeignKeysElement = AppendChildElement( columnElement, "ForeignKeys" );

                    foreach( System.Data.DataRow row in column.EnumForeignKeys().Rows )
                    {
                        var columnForeignKeyElement = AppendChildElement( columnForeignKeysElement, "ForeignKey" );
                        AppendAttribute( columnForeignKeyElement, "Schema", row[0].ToString() );
                        AppendAttribute( columnForeignKeyElement, "ColumName", row[1].ToString() );
                        AppendAttribute( columnForeignKeyElement, "ForeignKeyName", row[2].ToString() );
                    }
                }
            }

            if( table.ForeignKeys.Count >= 1 )
            {   
                var tableForeignKeysElement = AppendChildElement( tableElement, "ForeignKeys" );
                foreach( ForeignKey foreignKey in table.ForeignKeys )
                {
                    var foreignKeyElement = AppendChildElement( tableForeignKeysElement, "ForeignKey" );
                    AppendAttribute( foreignKeyElement, "Name", foreignKey.Name );
                    AppendAttribute( foreignKeyElement, "ReferencedKey", foreignKey.ReferencedKey );
                    AppendAttribute( foreignKeyElement, "ReferencedTable", foreignKey.ReferencedTable );
                    InsertCommentBefore( foreignKeyElement, "The ForeignKey Name is the name of the FK.  ReferencedKey is the name of the index on the \"other\" side." );

                    var foreignKeyColumnsElement = AppendChildElement( foreignKeyElement, "Columns" );
                    foreach( ForeignKeyColumn column in foreignKey.Columns )
                    {   
                        // http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.foreignkeycolumn.aspx
                        var foreignKeyColumnElement = AppendChildElement( foreignKeyColumnsElement, "Column" );
                        AppendAttribute( foreignKeyColumnElement, "Name", column.Name );
                        AppendAttribute( foreignKeyColumnElement, "ReferencedColumn", column.ReferencedColumn );
                        InsertCommentBefore( foreignKeyColumnElement, "Column Name is the column of this table while ReferencedColumn means the column of the other table." );
                    }
                }
            }

            if( table.Indexes.Count >= 1 )
            {
                var indexesElement = AppendChildElement( tableElement, "Indexes" );
                foreach( Index index in table.Indexes )
                {
                    //  http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.index.aspx
                    var indexElement = AppendChildElement( indexesElement, "Index" );
                    AppendAttribute( indexElement, "Name", index.Name );
                    //  http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.indexkeytype.aspx
                    AppendAttribute( indexElement, "IndexType", 
                        index.IndexKeyType == IndexKeyType.None ? "NotUnique" :
                        index.IndexKeyType == IndexKeyType.DriPrimaryKey ? "PrimaryKey" :
                        index.IndexKeyType == IndexKeyType.DriUniqueKey ? "Unique" :
                        "Unknown - Error in script"
                    );
                    var indexColumnsElement = AppendChildElement( indexElement, "Columns" );
                    foreach( IndexedColumn column in index.IndexedColumns )
                    {
                        // http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.indexedcolumn.aspx
                        var indexColumnElement = AppendChildElement( indexColumnsElement, "Column" );
                        AppendAttribute( indexColumnElement, "Name", column.Name );
                    }
                }
            }

        }

        Out( FormatXml( doc ) );
    }

    private XmlComment InsertCommentBefore( XmlElement element, string comment )
    {
        var newCommentElement = element.OwnerDocument.CreateComment( comment );
        element.ParentNode.InsertBefore( newCommentElement, element );
        return newCommentElement;
    }

    private XmlAttribute AppendAttribute( XmlElement element, string name, string value )
    {
        var newAttribute = element.OwnerDocument.CreateAttribute( name );
        newAttribute.Value = value;
        element.Attributes.Append( newAttribute );
        return newAttribute;
    }

    private XmlAttribute AppendAttribute( XmlElement element, string name, bool value )
    {
        return AppendAttribute( element, name, value.ToString() );
    }

    private XmlAttribute AppendAttribute( XmlElement element, string name, int value )
    {
        return AppendAttribute( element, name, value.ToString() );
    }

    private XmlElement AppendChildElement( XmlElement parentElement, string elementName )
    {
        var newElement = parentElement.OwnerDocument.CreateElement( elementName );
        parentElement.AppendChild( newElement );
        return newElement;
    }

    //  Copied from http://forums.asp.net/t/1145533.aspx/1
private string FormatXml(XmlNode xmlNode) 
{         
    StringBuilder bob = new StringBuilder(); 
 
    // We will use stringWriter to push the formated xml into our StringBuilder bob. 
    using (StringWriter stringWriter = new StringWriter(bob)) 
    { 
        // We will use the Formatting of our xmlTextWriter to provide our indentation. 
        using (XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter)) 
        { 
            xmlTextWriter.Formatting = Formatting.Indented; 
            xmlNode.WriteTo(xmlTextWriter); 
        } 
    } 
 
    return bob.ToString(); 
} 

#>
