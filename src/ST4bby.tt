<#@ Include File="ST4bby.Config.ttinclude" #>
<#@ Assembly Name="System.Xml" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="Microsoft.SqlServer.ConnectionInfo" #>
<#@ Assembly Name="Microsoft.SqlServer.Management.Sdk.Sfc" #>
<#@ Assembly Name="Microsoft.SqlServer.Smo" #>
<#@ Assembly Name="System.Data" #>
<#@ Assembly Name="EnvDTE" #>
<#@ Import Namespace="Microsoft.SqlServer.Management.Smo" #>
<#@ Import Namespace="System.Xml.Serialization" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Data.Common" #>
<#@ Import Namespace="System.Text.RegularExpressions" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="Microsoft.SqlServer.Management.Common" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="EnvDTE" #>
<#
  if (ConfigIsValid())
    {
      var connectionString = GetConnectionString();
        using(SqlConnection conn = new SqlConnection(connectionString))
        {
            var serverConnection = new ServerConnection(conn);
            var tables = new Server(serverConnection).Databases[databaseName].Tables;

            OutputXml( new Server(serverConnection).Databases[databaseName] );
            var xmlPath = SaveOutput( "ST4bby.xml" );
            AddFileToProject( xmlPath );

            foreach (Table table in tables)
            {
                if ( IsClassOkToGenerate( table ) )
                {
                    OutputClass(nameSpaceName, table);
                    var path = SaveOutput(table.Name + ".cs");
                    // total hack but it adds the newly written file into the current visual studio instance
                    var project = GetCurrentProject();

                    project.ProjectItems.AddFromFile(path);
                }
            }
        }
    }
#>
<#+
	
    private readonly static Dictionary<string, string> TypeMappings = new Dictionary<string, string> 
    {
        { "bit","bool" },           { "uniqueidentifier","Guid" },
        { "datetime","DateTime" },  { "datetime2","DateTime" },
        { "int","int" },            { "smallint","short" },
        { "bigint","long" },        { "varchar","string" },
        { "nchar","char" },         { "char","char" },
        { "nvarchar","string" },    { "text","string" },
        { "ntext","string" }
    };
	
    private void AddFileToProject( string xmlPathAndFile )
    {
        // total hack but it adds the newly written file into the current visual studio instance
        var project = GetCurrentProject();
        project.ProjectItems.AddFromFile( xmlPathAndFile );
    }

    public EnvDTE.Project GetCurrentProject()
    {
        var serviceProvider             = (IServiceProvider)Host;
        var dte                         = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
        var currentSlnProjects          = (Array)dte.ActiveSolutionProjects;

        return (EnvDTE.Project)currentSlnProjects.GetValue(0);
    }
	
	/// <summary> This method creates the signature for the class.
    /// E.g.: public partial class Customer()
    /// </summary>
    /// <param name="table"></param>
    /// <param name="usePartialClass"></param>
    /// <returns></returns>
   private static string CreateClassSignature( Table table, bool usePartialClass )
   {
     var ret = "public";
	if( usePartialClass )
	{
		ret += " partial";
	}
     return ret + " class " + table.Name;
   }

    private static string CreateFileHeader( string commentPrefix, string commentSuffix = null )
    {
        return 
            string.Format( 
            "{2} This class is automatically generated by ST4bby {1}.{3]{0}" +
            "{2} Read more at https://github.com/jbubriski/ST4bby/{3}" , 
                Environment.NewLine, 
                System.DateTime.Now.ToString(), 
                commentPrefix, 
                commentSuffix );
    }

	/// <summary> This method creates the namespace signature.
	/// </summary>
	/// <param name="namespaceName"></param>
	/// <param name="table"></param>
	/// <param name="useSchemaForNamespace"></param>
	/// <returns></returns>
	private static string CreateNamespaceSignature( string namespaceName, Table table, bool useSchemaForNamespace )
	{
		string ret = string.Format( "namespace {0}", namespaceName );
		if( useSchemaForNamespace )
		{
			ret += "." + table.Schema;
		}
		return ret;
	}
	
    /// <summary> This method creates a parameter for a method from a column.
    /// E.g.: "int CustomerID" or "string Name".
    /// </summary>
    /// <param name="column"></param>
    /// <returns></returns>
	private static string CreateMethodParameter( Column column )
	{
        var isNullable       = column.Nullable;
        var type             = TypeMappings.ContainsKey(column.DataType.Name) ? TypeMappings[column.DataType.Name] : "string";
        var typeFormat       = type != "string" && isNullable ? "Nullable<{0}>" : "{0}";

        return String.Format("{0} {1}", String.Format(typeFormat,type), column.Name);
	}

    /// <summary> This method creates a method signature.
    /// E.g.: "private void Set( CustomerID, Name )".
    /// </summary>
    /// <param name="scope"></param>
    /// <param name="isStatic"></param>
    /// <param name="returnType"></param>
    /// <param name="methodName"></param>
    /// <param name="columns"></param>
    /// <param name="includePrimaryKey">Whether the primary key should be included or not.
    /// New objects often can't have the PK set at the client, only in the database.</param>
    /// <returns></returns>
	private static string CreateMethodSignature( string scope, bool isStatic, string returnType, string methodName, ColumnCollection columns, bool includePrimaryKey = true )
	{
		string ret = scope;
		if( isStatic )
		{
			ret += " static";
		}
		if( false == string.IsNullOrWhiteSpace( returnType ) )
		{
			ret += " " + returnType;
		}
		ret += " " + methodName + "(";
		if( null != columns )
		{
			var paramList = new List<string>();
			foreach( Column column in columns )
			{
				if( column.InPrimaryKey && ! includePrimaryKey )
				{
					//	The column is part of the primary key and we don't want it according to parameter.
				}
				else
				{
					paramList.Add( CreateMethodParameter( column ) );
				}
			}
			ret += " " + string.Join( ", ", paramList.ToArray() ) + " ";
		}
		ret += ")";
		return ret;
	}

    /// <summary> This method creates all parameters for a constructor.
    /// It is not necessarily only for constructor use.  A method like "Set( CustomerID, Name, ...)"
    /// could use it too.  Rename it when need arises.
    /// </summary>
    /// <param name="columns"></param>
    /// <param name="includePrimaryKey"></param>
    /// <returns></returns>
	private static string CreateNamedArgumentListForConstructor( ColumnCollection columns, bool includePrimaryKey = true )
	{
		var assignmentList = new List<string>();
		foreach( Column column in columns )
		{
			if( column.InPrimaryKey && ! includePrimaryKey )
			{
				//	The column is part of the primary key and we don't want it according to parameter.
			}
			else
			{
				assignmentList.Add( column.Name + " = " + column.Name );
			}	
		}
		return string.Join( "," + Environment.NewLine, assignmentList.ToArray() );
	}
	
    /// <summary> This method returns true if the table is among the ones that should generate code.
    /// Typically aren't system objects and explicitly excluded tables among those.
    /// </summary>
    /// <param name="table">The table in question.</param>
    /// <returns></returns>
    private bool IsClassOkToGenerate( Table table )
    {
        if( false == string.IsNullOrWhiteSpace( ExcludeTablesRegex ) &&
            ( table.IsSystemObject || Regex.IsMatch( table.Name, ExcludeTablesRegex ) ) )
        {
            return false;
        }else{
            return true;
        }
    }

	private string OutputProperty(Column column)
    {
        var isNullable       = column.Nullable;
        var type             = TypeMappings.ContainsKey(column.DataType.Name) ? TypeMappings[column.DataType.Name] : "string";
        var typeFormat       = type != "string" && isNullable ? "Nullable<{0}>" : "{0}";

        var annotations      = GetAnnotations(column);

        return String.Format("{0}public {1} {2} {{ get; set; }}", annotations, String.Format(typeFormat,type), column.Name);
    }

    string GetAnnotations(Column col)
    {
      var builder = new List<string>();
        var canHaveLength = new string[] { "nvarchar", "varchar", "char", "nchar" };
        if (canHaveLength.Contains(col.DataType.Name) && col.DataType.MaximumLength > -1)
            builder.Add( String.Format("StringLength({0})", col.DataType.MaximumLength));

        if (!col.Nullable)
            builder.Add("Required");

        if (col.InPrimaryKey)
          builder.Add("Key");

        var notations = String.Join(", ", builder);
      return builder.Count > 0 ? String.Format("[{0}]{1}", notations, System.Environment.NewLine) : String.Empty;
  }

    System.Collections.Generic.IEnumerable<string> GatherProperties(ColumnCollection columns)
    {
        foreach (Column col in columns)
            yield return OutputProperty(col);
    }

    void Out(string stuff)
    {
#><#= stuff + System.Environment.NewLine #><#+
    }

    void Out(string stuff, params object[] args)
    {
#><#= String.Format(stuff, args) + System.Environment.NewLine #><#+
    }

    string SaveOutput(string outputFileName)
    {
        // By some reason unknown to me the file the string contains a leading whitespace.  Hence the Trim.
        // This happened to me while writing an XML file which doesn't tolerate a leading whitespace. /OF
      var content = this.GenerationEnvironment.ToString().Trim();
      string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
      string outputFilePath = Path.Combine(templateDirectory, outputFileName);

        File.WriteAllText(outputFilePath, content);

      this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);

        return outputFilePath;
    }

    void OutputClass(string namespaceName, Table table)
    {
		Out("// This class is automatically generated by ST4bby {0}.", System.DateTime.Now.ToString());
		Out("// Read more at https://github.com/jbubriski/ST4bby/");
		Out("");
		Out( CreateNamespaceSignature( namespaceName, table, UseSchemaForNamespace ) );
		Out("{");
		PushIndent("\t");
			Out("using System;");
			Out("using System.ComponentModel.DataAnnotations;");
			Out( "" );
			Out( CreateClassSignature( table, UsePartialClass ) );
			Out("{");
			PushIndent("\t");
				//	Properties.
				var properties = GatherProperties(table.Columns);
				Out(String.Join(System.Environment.NewLine, properties));
		
				//	Static constructors.
				if( false == string.IsNullOrWhiteSpace( NameOfStaticConstructor ) )
				{
					Out("");
			        Out( "/// <summary> This static constructor takes all fields but the primary key." );
			        Out( "/// </summary>");
			        Out( "/// <returns></returns>");
					Out( CreateMethodSignature( "public", true, table.Name, NameOfStaticConstructor, table.Columns, includePrimaryKey : false ) );
					Out("{");
					PushIndent("\t");
						Out( "return new " + table.Name + "()" );
						Out( "{" );
						PushIndent("\t");
							Out( CreateNamedArgumentListForConstructor( table.Columns, includePrimaryKey : false ) );
						PopIndent();
						Out( "};" );
					PopIndent();
					Out("}");
					Out("");
			        Out( "/// <summary> This static constructor takes all fields including the primary key." );
			        Out( "/// </summary>");
			        Out( "/// <returns></returns>");
					Out( CreateMethodSignature( "public", true, table.Name, NameOfStaticConstructor, table.Columns ) );
					Out("{");
					PushIndent("\t");
						Out( "return new " + table.Name + "()" );
						Out( "{" );
						PushIndent("\t");
							Out( CreateNamedArgumentListForConstructor( table.Columns, includePrimaryKey : true ) );
						PopIndent();
						Out( "};" );
					PopIndent();
					Out("}");
				}
			PopIndent();
			Out("}");
		PopIndent();
		Out("}");
    }

    private void OutputXml( Database database )
    {
        //  http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.aspx

        var doc = new XmlDocument();

        // Important to set the ProcessingInstruction through code, otherwise we will have no
        // DocumentElement to use. (so we do a doc.appendChild and then we suddenly
        // have 2 roots)
        doc.AppendChild(doc.CreateProcessingInstruction("xml", "version=\"1.0\" encoding=\"UTF-8\""));

        var elem = doc.CreateElement( "Database" );
        doc.AppendChild( elem );
        var databaseRoot = doc.DocumentElement;

        InsertCommentBefore( databaseRoot, "This class is automatically generated by ST4bby " + DateTime.Now.ToString() + "." );
        InsertCommentBefore( databaseRoot, "Read more at https://github.com/jbubriski/ST4bby/" );

        AppendAttribute( databaseRoot, "Name", database.Name );
        
        foreach( Table table in database.Tables )
        {
            var tableElement = AppendChildElement( databaseRoot, "Table" );
            AppendAttribute( tableElement, "Name", table.Name );
            AppendAttribute( tableElement, "Include", IsClassOkToGenerate( table ) );
            AppendAttribute( tableElement, "Schema", table.Schema );

            var columnsElement = AppendChildElement( tableElement, "Columns" );

            foreach( Column column in table.Columns )
            {
                var columnElement = AppendChildElement( columnsElement, "Column" );
                AppendAttribute( columnElement, "Name", column.Name );
                AppendAttribute( columnElement, "IsNullable", column.Nullable );
                AppendAttribute( columnElement, "DbType", column.DataType.ToString() );
                var type = TypeMappings.ContainsKey(column.DataType.Name) ? TypeMappings[column.DataType.Name] : "string";
                var typeFormat       = type != "string" && column.Nullable ? "Nullable<{0}>" : "{0}";
                AppendAttribute( columnElement, "DotnetType", String.Format(typeFormat,type) );
                AppendAttribute( columnElement, "PrimaryKey", column.InPrimaryKey );

                //  Foreign keys are printed if any exists.
                if( column.EnumForeignKeys().Rows.Count >= 1 )
                {
                    var columnForeignKeysElement = AppendChildElement( columnElement, "ForeignKeys" );

                    foreach( System.Data.DataRow row in column.EnumForeignKeys().Rows )
                    {
                        var columnForeignKeyElement = AppendChildElement( columnForeignKeysElement, "ForeignKey" );
                        AppendAttribute( columnForeignKeyElement, "ColumName", row[1].ToString() );
                        AppendAttribute( columnForeignKeyElement, "ForeignKeyName", row[2].ToString() );
                    }
                }
            }

            var foreignKeysElement = AppendChildElement( tableElement, "ForeignKeys" );
            foreach( ForeignKey foreignKey in table.ForeignKeys )
            {
                var foreignKeyElement = AppendChildElement( foreignKeysElement, "ForeignKey" );
                AppendAttribute( foreignKeyElement, "Name", foreignKey.Name );
                foreach( ForeignKeyColumn column in foreignKey.Columns )
                {   
                    // http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.foreignkeycolumn.aspx
                    var foreignKeyColumnElement = AppendChildElement( foreignKeyElement, "Column" );
                    AppendAttribute( foreignKeyColumnElement, "Name", column.Name );
                    AppendAttribute( foreignKeyColumnElement, "ReferencedColumn", column.ReferencedColumn );
                    InsertCommentBefore( foreignKeyColumnElement, "Name is the column of this table while ReferencedColumn means the column of the other table." );
                }
            }

        }

        Out( FormatXml( doc ) );
    }

    private XmlComment InsertCommentBefore( XmlElement element, string comment )
    {
        var newCommentElement = element.OwnerDocument.CreateComment( comment );
        element.ParentNode.InsertBefore( newCommentElement, element );
        return newCommentElement;
    }

    private XmlAttribute AppendAttribute( XmlElement element, string name, string value )
    {
        var newAttribute = element.OwnerDocument.CreateAttribute( name );
        newAttribute.Value = value;
        element.Attributes.Append( newAttribute );
        return newAttribute;
    }

    private XmlAttribute AppendAttribute( XmlElement element, string name, bool value )
    {
        return AppendAttribute( element, name, value.ToString() );
    }

    private XmlElement AppendChildElement( XmlElement parentElement, string elementName )
    {
        var newElement = parentElement.OwnerDocument.CreateElement( elementName );
        parentElement.AppendChild( newElement );
        return newElement;
    }

    //  Copied from http://forums.asp.net/t/1145533.aspx/1
private string FormatXml(XmlNode xmlNode) 
{         
    StringBuilder bob = new StringBuilder(); 
 
    // We will use stringWriter to push the formated xml into our StringBuilder bob. 
    using (StringWriter stringWriter = new StringWriter(bob)) 
    { 
        // We will use the Formatting of our xmlTextWriter to provide our indentation. 
        using (XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter)) 
        { 
            xmlTextWriter.Formatting = Formatting.Indented; 
            xmlNode.WriteTo(xmlTextWriter); 
        } 
    } 
 
    return bob.ToString(); 
} 

#>
